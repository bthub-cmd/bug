#!/usr/bin/env python3
import yt_dlp
import sys
import os
import time

def download_tiktok(url):
    script_dir = os.path.dirname(os.path.abspath(__file__))
    output_dir = os.path.join(script_dir, '..', '..', 'cache')
    
    if not os.path.exists(output_dir):
        os.makedirs(output_dir, exist_ok=True)
    
    # Normalize URL
    url = url.strip()
    if not url.startswith('http'):
        url = 'https://' + url
    
    # Extract ID dari URL untuk tracking
    video_id = 'unknown'
    try:
        if '/video/' in url:
            video_id = url.split('/video/')[1].split('?')[0].split('/')[0]
        elif '/v/' in url:
            video_id = url.split('/v/')[1].split('?')[0]
        elif 'vm.tiktok.com' in url or 'vt.tiktok.com' in url:
            # Short URL, akan diresolve oleh yt-dlp
            pass
    except:
        pass
    
    ydl_opts = {
        'format': 'best',
        'outtmpl': os.path.join(output_dir, f'tt_{video_id}_%(id)s.%(ext)s'),
        'max_filesize': 100 * 1024 * 1024,
        'quiet': True,
        'no_warnings': True,
        'impersonate': 'chrome110',
        'http_headers': {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Referer': 'https://www.tiktok.com/',
            'Connection': 'keep-alive',
        },
        'extractor_args': {
            'tiktok': {
                'api_hostname': 'api16-normal-c-useast1a.tiktokv.com',
                'app_version': '20.1.0',
                'manifest_app_version': '20.1.0',
            }
        },
        'retries': 10,
        'fragment_retries': 10,
        'skip_unavailable_fragments': False,
    }
    
    downloaded_file = None
    
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            # Get info first
            info = ydl.extract_info(url, download=False)
            if info is None:
                raise Exception("Could not extract video info")
            
            # Update video_id dengan yang benar
            video_id = info.get('id', video_id)
            
            # Rebuild path dengan ID yang benar
            ydl_opts['outtmpl'] = os.path.join(output_dir, f'tt_{video_id}.%(ext)s')
            
            # Download dengan ydl baru
            with yt_dlp.YoutubeDL(ydl_opts) as ydl2:
                ydl2.download([url])
            
            # Cek file yang didownload
            possible_files = [
                os.path.join(output_dir, f'tt_{video_id}.mp4'),
                os.path.join(output_dir, f'tt_{video_id}.webm'),
                os.path.join(output_dir, f'tt_{video_id}.mkv'),
            ]
            
            for f in possible_files:
                if os.path.exists(f):
                    downloaded_file = f
                    break
            
            # Kalau tidak ketemu, cari file terbaru dengan prefix tt_
            if not downloaded_file:
                files = os.listdir(output_dir)
                tt_files = [f for f in files if f.startswith(f'tt_{video_id}') or f.startswith('tt_')]
                if tt_files:
                    # Sort by modification time
                    tt_files.sort(key=lambda x: os.path.getmtime(os.path.join(output_dir, x)), reverse=True)
                    downloaded_file = os.path.join(output_dir, tt_files[0])
            
            if not downloaded_file:
                raise Exception(f"Downloaded file not found in {output_dir}")
            
            # Cek size
            file_size = os.path.getsize(downloaded_file)
            
            # Tunggu file settle
            time.sleep(0.5)
            
            if file_size > 50 * 1024 * 1024:  # > 50MB
                print(f"TOOBIG:{downloaded_file}")
            else:
                print(downloaded_file)
                
    except Exception as e:
        error_str = str(e).lower()
        
        # Try fallback tanpa impersonate
        if 'impersonate' in error_str or 'unexpected response' in error_str or 'webpage' in error_str:
            try:
                print("Retrying without impersonate...", file=sys.stderr)
                
                fallback_opts = {
                    'format': 'best',
                    'outtmpl': os.path.join(output_dir, f'tt_{video_id}.%(ext)s'),
                    'max_filesize': 100 * 1024 * 1024,
                    'quiet': True,
                    'no_warnings': True,
                    'http_headers': {
                        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15',
                    },
                    'retries': 5,
                }
                
                with yt_dlp.YoutubeDL(fallback_opts) as ydl:
                    info = ydl.extract_info(url, download=False)
                    if info:
                        video_id = info.get('id', video_id)
                        fallback_opts['outtmpl'] = os.path.join(output_dir, f'tt_{video_id}.%(ext)s')
                        
                        with yt_dlp.YoutubeDL(fallback_opts) as ydl2:
                            ydl2.download([url])
                        
                        # Cari file
                        files = os.listdir(output_dir)
                        tt_files = [f for f in files if f.startswith(f'tt_{video_id}') or f.startswith('tt_')]
                        if tt_files:
                            tt_files.sort(key=lambda x: os.path.getmtime(os.path.join(output_dir, x)), reverse=True)
                            downloaded_file = os.path.join(output_dir, tt_files[0])
                            file_size = os.path.getsize(downloaded_file)
                            
                            time.sleep(0.5)
                            
                            if file_size > 50 * 1024 * 1024:
                                print(f"TOOBIG:{downloaded_file}")
                            else:
                                print(downloaded_file)
                            return
                            
            except Exception as e2:
                print(f"Fallback also failed: {e2}", file=sys.stderr)
        
        # Error handling
        if 'private' in error_str or 'login' in error_str:
            print("ERROR: Video is private or requires login", file=sys.stderr)
        elif 'not found' in error_str or '404' in error_str:
            print("ERROR: Video not found or removed", file=sys.stderr)
        elif 'unavailable' in error_str or 'removed' in error_str:
            print("ERROR: Video unavailable or removed by user", file=sys.stderr)
        elif 'age' in error_str or 'restricted' in error_str:
            print("ERROR: Age restricted content", file=sys.stderr)
        else:
            print(f"ERROR: {e}", file=sys.stderr)
        
        sys.exit(1)

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("ERROR: URL required", file=sys.stderr)
        sys.exit(1)
    
    url = sys.argv[1]
    download_tiktok(url)g
